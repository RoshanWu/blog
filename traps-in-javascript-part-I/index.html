
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="zh-CN"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>JavaScript 中的一些坑（一） - 肉山·察</title>
  <meta name="author" content="Roshan Wu">
  <meta name="Generator" content="Jekyll & Octopress (http://octopress.org)">

  
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://roshanca.com/traps-in-javascript-part-I/">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/octopress.min.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="肉山·察" type="application/atom+xml">
  

<!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Sans' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-15720258-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


  
  <link href="/favicon.png" rel="icon">
</head>

<body>
  <header role="banner">
    <hgroup>
  <h1><a href="/">肉山·察</a></h1>
  
    <h2>用 Mac 写前端的男人</h2>
  
</hgroup>

  <div id="social-links">
    <ul>
      <li id="social-links-github">
        <a title="github" href="https://github.com/RoshanWu">github</a>
      </li>
      <li id="social-links-twitter">
        <a title="twitter" href="http://twitter.com/roshan_wu">twitter</a>
      </li>
      <li id="social-links-weibo">
        <a title="weibo" href="http://weibo.com/jinfeixibi/">weibo</a>
      </li>
      <li id="social-links-feed">
        <a title="feed" href="http://roshanca.com/atom.xml">feed</a>
      </li>
    </ul>
  </div>




  </header>
  
  <div id="content">
    <article class="hentry " role="article">
  
  <header>
    <h2 class="entry-title">
JavaScript 中的一些坑（一）
</h2>

  </header>

<div class="entry-content"><p>“坑”这个字，在此的意思是“陷阱”。由于 JavaScript “弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“中招”。这些坑往往隐藏着，所以必须擦亮双眼，才能在学习与应用 JS 的道路上走的一帆风顺。</p>

<h2>全局变量</h2>

<blockquote><p>  JavaScript 通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。</p></blockquote>

<p>“未声明直接简单使用”，指的是不用 <code>var</code> 关键字来声明变量。这个我们已经非常清楚，避免造成隐式产生全局变量的方法就是声明变量尽量用 <code>var</code> 关键字。</p>

<p>可你以为用了 <code>var</code> 就 ok 了？来看看这个坑：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</div><div class='line'>    <span class="c1">// body...</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>也许你期望得到的是两个局部变量，但 <code>b</code> 却是货真价实的全局变量。why? Because <strong> 赋值运算是自右往左的 </strong>，所以这相当于：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
</div><div class='line'>    <span class="c1">// body...</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>所以 <code>b</code> 是全局变量。</p>

<p>填坑：变量声明，最好一个个来，别搞批发~_~;</p>

<h2>变量声明</h2>

<p>先来看坑：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">;</span>
</div><div class='line'> </div><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">;</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span>
</div><div class='line'><span class="p">}</span>
</div><div class='line'> </div><div class='line'><span class="nx">foo</span><span class="p">();</span>
</div></pre></div></figure>


<p>乍看上去，我们预计期望两次 <code>alert</code> 的结果分别为 &#8220;global&#8221; 与 &#8220;local&#8221;，但真实的结果是 &#8220;undefined&#8221; 与 &#8220;local&#8221;。why? Because <strong> 变量在同一作用域（同一函数）中，声明都是被提至作用域顶部先进行解析的。 </strong></p>

<p>所以以上代码片段的执行行为可能就像这样：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">myName</span><span class="p">;</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>
</div><div class='line'>    <span class="nx">myName</span> <span class="o">=</span> <span class="s2">&quot;local&quot;</span><span class="p">;</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="nx">myName</span><span class="p">);</span> <span class="c1">// &quot;local&quot;</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>用另一个坑来测试下你是否真的理解了预解析：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</div><div class='line'><span class="p">}</span>
</div><div class='line'> </div><div class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
</div></pre></div></figure>


<p><code>a</code> 变量的声明被提前到了代码顶端，此时还未赋值。接下来进入 <code>if</code> 语句，判断条件中 <code>"a" in window</code> 已成立（<code>a</code> 已被声明为全局变量），所以判断语句计算结果为 <code>false</code>，直接就跳出 <code>if</code> 语句了，所以 <code>a</code> 的值为 <code>undefined</code>。</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">var</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">// &quot;undefined&quot;</span>
</div><div class='line'><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>
</div><div class='line'> </div><div class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="s2">&quot;a&quot;</span> <span class="k">in</span> <span class="nb">window</span><span class="p">))</span> <span class="p">{</span>
</div><div class='line'>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 不执行</span>
</div><div class='line'><span class="p">}</span>
</div><div class='line'> </div><div class='line'><span class="nx">alert</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>
</div></pre></div></figure>


<p>填坑：变量声明，最好手动置于作用域顶部，对于无法当下赋值的变量，可采取先声明后赋值的手法。</p>

<h2>函数声明</h2>

<p><strong> 函数声明也是被提前至作用域顶部，先于任何表达式和语句被解析和求值的 </strong></p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// &quot;function&quot;</span>
</div><div class='line'> </div><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="c1">// body...</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>可以对比一下：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="nx">alert</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">foo</span><span class="p">);</span> <span class="c1">// &quot;undefined&quot;</span>
</div><div class='line'> </div><div class='line'><span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="c1">// body...</span>
</div><div class='line'><span class="p">};</span>
</div></pre></div></figure>


<p>明白了这个道理的你，是否还会踩以下的坑呢？</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">);</span>
</div><div class='line'><span class="p">}</span>
</div><div class='line'> </div><div class='line'><span class="nx">test</span><span class="p">();</span>
</div><div class='line'> </div><div class='line'><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;2&quot;</span><span class="p">);</span>
</div><div class='line'><span class="p">}</span>
</div><div class='line'> </div><div class='line'><span class="nx">test</span><span class="p">();</span>
</div></pre></div></figure>


<p>运行以上代码片段，看到的两次弹窗显示的都是 &#8220;2&#8221;，为什么不是分别为 &#8220;1&#8221; 和 &#8220;2&#8221; 呢？很简单，<code>test</code> 的声明先于 <code>test()</code> 被解析，由于后者覆盖前者，所以两次执行的结果都是 &#8220;2&#8221;。</p>

<p>填坑：多数情况下，我用函数表达式来代替函数声明，特别是在一些语句块中。</p>

<h2>函数表达式</h2>

<p>先看命名函数表达式，理所当然，就是它得有名字，例如：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="c1">// body...</span>
</div><div class='line'><span class="p">};</span>
</div></pre></div></figure>


<p>要注意的是：函数名只对其函数内部可见。如以下坑：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// 正常运行</span>
</div><div class='line'><span class="p">};</span>
</div><div class='line'> </div><div class='line'><span class="nx">foo</span><span class="p">();</span> <span class="c1">// 出错：ReferenceError</span>
</div></pre></div></figure>


<p>填坑：尽量少用命名函数表达式（除了一些递归以及 debug 的用途），切勿将函数名使用于外部。</p>

<h2>函数的自执行</h2>

<p>对于函数表达式，可以通过后面加上 <code>()</code> 自执行，而且可在括号中传递参数，而函数声明不可以。坑：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="c1">// (1) 这只是一个分组操作符，不是函数调用！</span>
</div><div class='line'><span class="c1">// 所以这里函数未被执行，依旧是个声明</span>
</div><div class='line'><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">}(</span><span class="mi">1</span><span class="p">);</span>
</div></pre></div></figure>


<p>以下代码片段分别执行都弹窗显示 &#8220;1&#8221;，因为在 <code>(1)</code> 之前，都为函数表达式，所以这里的 <code>()</code> 非分组操作符，而为运算符，表示调用执行。</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="c1">// 标准的匿名函数表达式</span>
</div><div class='line'><span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">}(</span><span class="mi">1</span><span class="p">);</span>
</div><div class='line'> </div><div class='line'><span class="c1">// 前面的 () 将 function 声明转化为了表达式</span>
</div><div class='line'><span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">})(</span><span class="mi">1</span><span class="p">);</span>
</div><div class='line'> </div><div class='line'><span class="c1">// 整个 () 内为表达式</span>
</div><div class='line'><span class="p">(</span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">}(</span><span class="mi">1</span><span class="p">));</span>
</div><div class='line'> </div><div class='line'><span class="c1">// new 表达式</span>
</div><div class='line'><span class="k">new</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">}(</span><span class="mi">1</span><span class="p">);</span>
</div><div class='line'> </div><div class='line'><span class="c1">// &amp;&amp;, ||, !, +, -, ~ 等操作符（还有逗号），在函数表达式和函数声明上消除歧义</span>
</div><div class='line'><span class="c1">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span>
</div><div class='line'><span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>  <span class="nx">alert</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
</div><div class='line'><span class="p">}(</span><span class="mi">1</span><span class="p">);</span><span class="err">​</span>
</div></pre></div></figure>


<p>填坑：这个坑的关键在于，弄清楚形形色色函数表达式的实质。</p>

<h2>循环中的闭包</h2>

<p>以下演示的是一个常见的坑：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/GNDd4/embedded/result,html,js/light/"></iframe>




<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;ul&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span>
</div><div class='line'> </div><div class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>        <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
</div><div class='line'>        <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">i</span><span class="p">);</span>
</div><div class='line'>    <span class="p">}</span>        
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>我们预期当点击第 <code>i</code> 个链接时，得到此序列索引 <code>i</code> 的值，可实际无论点击哪个链接，得到的都是 <code>i</code> 在循环后的最终结果：&#8221;5&#8221;。</p>

<p>解释一下原因：当 <code>alert</code> 被调用时，<code>for</code> 循环内的匿名函数表达式，保持了对外部变量 <code>i</code> 的引用（闭包），此时循环已结束，<code>i</code> 的值被修改为 &#8220;5&#8221;。</p>

<p>填坑：为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的拷贝。以下演示正确的做法：</p>

<iframe style="width: 100%; height: 300px" src="http://jsfiddle.net/UTy8Z/embedded/result,html,js/light/"></iframe>




<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;ul&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">].</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">);</span>
</div><div class='line'> </div><div class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>    <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>        <span class="k">return</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
</div><div class='line'>            <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>
</div><div class='line'>        <span class="p">}</span>
</div><div class='line'>    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>可以看到，<code>(function () { ... })()</code> 的形式，就是上文提到的<strong> 函数的自执行 </strong>，<code>i</code> 作为参数传给了 <code>index</code>，<code>alert</code> 再次执行时，它就拥有了对 <code>index</code> 的引用，此时这个值是不会被循环改变的。当然，明白了其原理后，你也可以这样写：</p>

<figure class='code'><div class='highlight'><pre class='main  js'><div class='line'><span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">l</span> <span class="o">=</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>    <span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>        <span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="p">{</span>
</div><div class='line'>            <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
</div><div class='line'>            <span class="nx">alert</span><span class="p">(</span><span class="s2">&quot;You click link #&quot;</span> <span class="o">+</span> <span class="nx">index</span><span class="p">);</span>
</div><div class='line'>        <span class="p">}</span>
</div><div class='line'>    <span class="p">})(</span><span class="nx">i</span><span class="p">);</span>
</div><div class='line'><span class="p">}</span>
</div></pre></div></figure>


<p>It works too.</p>

<p>To be continued&#8230;</p>
</div>


  <footer>
    <p class="meta">
      








  


<time datetime="2012-11-29T14:47:00+08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2012</time>


<span class="categories">
  
    <a class='category' href='/blog/categories/javascript/'>javascript</a>
  
</span>



      

    </p>
  </footer>
</article>

<section>
  

  
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  
</section>

  </div>
  
  <footer role="contentinfo"><hr class="end">
<p>
  Copyright &copy; 2013 - Roshan Wu -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> & <a href="https://github.com">GitHub</a></span>
</p>

</footer>
  
  

<script type="text/javascript">
      var disqus_shortname = 'Roshanca';
			var disqus_developer = '0';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://roshanca.com/traps-in-javascript-part-I/';
        var disqus_url = 'http://roshanca.com/traps-in-javascript-part-I/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







</body>
</html>
